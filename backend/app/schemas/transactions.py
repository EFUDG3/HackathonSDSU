from pydantic import BaseModel, condecimal
from typing import Optional
from datetime import date, datetime
from decimal import Decimal
from uuid import UUID

'''
Transaction schema for financial tracking.
Follows the same pattern as FinancialsBase/Create/Update/Response.

When a transaction is created, it should trigger an update to the 
corresponding financials record based on category mapping:
- category "Donation" or "Donations" -> revenue_donations
- category "Fundraising" -> revenue_fundraising  
- category "Sponsorship" -> revenue_sponsorship
- category "Food" -> expense_food
- category "Giveaway" -> expense_giveaway
- category "Uniforms" -> expense_uniforms
'''

Money = condecimal(max_digits=12, decimal_places=2)


class TransactionsBase(BaseModel):
    club_id: int  # BIGINT (int8)
    amount: Money
    category: str  # varchar
    description: Optional[str] = None  # text
    date: date
    status: str = "completed"  # varchar, default to "completed"
    vendor: Optional[str] = None  # varchar
    receipt_url: Optional[str] = None  # text
    code: Optional[str] = None  # text


class TransactionsCreate(TransactionsBase):
    """
    All fields the client must provide to create a transaction.
    Inherits all fields from TransactionsBase.
    Note: id and created_at are auto-generated by Supabase.
    """
    pass


class TransactionsUpdate(BaseModel):
    """
    All fields optional for partial updates.
    """
    club_id: Optional[int] = None
    amount: Optional[Money] = None
    category: Optional[str] = None
    description: Optional[str] = None
    date: Optional[date] = None
    status: Optional[str] = None
    vendor: Optional[str] = None
    receipt_url: Optional[str] = None
    code: Optional[str] = None


class TransactionsResponse(TransactionsBase):
    """
    What the API returns: Base fields + server-generated fields.
    """
    id: UUID  # uuid (uu1d)
    created_at: datetime  # timestamptz from Supabase


# Category mapping for updating financials
# Maps category names (case-insensitive) to financial field names
CATEGORY_TO_FINANCIAL_FIELD = {
    "donation": "revenue_donations",
    "donations": "revenue_donations",
    "fundraising": "revenue_fundraising",
    "sponsorship": "revenue_sponsorship",
    "food": "expense_food",
    "giveaway": "expense_giveaway",
    "uniforms": "expense_uniforms",
}


def get_financial_field_for_category(category: str) -> Optional[str]:
    """
    Helper function to map transaction category to financial field name.
    Returns None if category doesn't map to a financial field.
    Case-insensitive lookup.
    """
    return CATEGORY_TO_FINANCIAL_FIELD.get(category.lower())


def is_revenue_category(category: str) -> bool:
    """Check if category is a revenue type."""
    return category.lower() in ["donation", "donations", "fundraising", "sponsorship"]


def is_expense_category(category: str) -> bool:
    """Check if category is an expense type."""
    return category.lower() in ["food", "giveaway", "uniforms"]
